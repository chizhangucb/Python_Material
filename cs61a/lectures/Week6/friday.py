def list_demos():
    suits = ['coin', 'string', 'myriad']  # A list literal
    original_suits = suits
    suits.pop()             # Removes and returns the final element
    suits.remove('string')  # Removes the first element that equals the argument
    suits.append('cup')              # Add an element to the end
    suits.extend(['sword', 'club'])  # Add all elements of a list to the end
    suits[2] = 'spade'  # Replace an element
    suits
    original_suits  # Same result as suits => changes one will reflect the other
    suits[0:2] = ['heart', 'diamond']  # Replace a slice
    [suit.upper() for suit in suits]
    [suit[1:4] for suit in suits if len(suit) == 5]

# Some objects can change
# All names that refer to the same object are affected by a MUTATION
# Only objects of mutable type can change: lists and dictionaries
# Mutation can happen within a function call
# A function can change the value of any object in its scope.

def mystery(s):
    # Within the function frame
    s.pop()
    s.pop()

four = [1, 2, 3, 4]; len(four)
mystery(four); len(four)

def another_mystery():
    # Within the global frame
    four.pop()
    four.pop()

four = [1, 2, 3, 4]; len(four)
another_mystery(); len(four)

def dict_demos():
    numerals = {'I': 1.0, 'V': 5, 'X': 10}
    numerals['X']
    numerals['I'] = 1  # Change the value of one key 
    numerals['L'] = 50 # Add one more pair to the dictionary
    numerals
    numerals.pop("X")  # Removes and returns the pair with the key "X"
    sum(numerals.values())
    dict([(3, 9), (4, 16), (5, 25)])
    numerals.get('A', 0)
    numerals.get('V', 0)
    {x: x*x for x in range(3,6)}
    # {[1]: 2}
    # {1: [2]}

# Tuple is immutable value
# An immutable sequence may still change if it contains a mutable value as an element

s = ([1, 2], 3)   # s[0] = 4 => error
s[0][0] = 4       # s == ([4, 2], 3)

def tuple_demos():
    (3, 4, 5, 6)
    3, 4, 5, 6
    ()
    tuple()
    tuple([1, 2, 3])
    # tuple(2) # doesn't work
    (2,)       # 2, => with only one element
    (3, 4) + (5, 6)
    (3, 4, 5) * 2
    5 in (3, 4, 5)
    {(1, 2): 3}
    # {([1], 2): 3}   # wrong => cannot have list within the tuple for dict
    {tuple([1, 2]): 3}

def divide_exact(n, d):
    return n // d, n % d

# Identity objects are alway equal values

def identity_demos():
    # A list is still 'the same' even if we change its contents
    a = [10]
    b = a    
    a == b   # Equality; evaluates to True if both evaluate to the equal values
    a is b   # Identity operator: evaluates to True if both evaluate to the same object
    a.extend([20, 30])
    a == b   # True
    a is b

    # Conversely, we could have two lists that happendto have the same contents, but are different
    a = [10]
    b = [10]
    c = b
    c is b      # True
    a == b      # True
    a is not b  # True
    a.append(20)
    a != b      # True

# Mutable Default Arguments are Dangerous
# A default argument value is part of a function value, not generated by a call

def f(s=[]):
    s.append(5)
    return len(s)
f()   # 1
f()   # 2
f()   # 3
